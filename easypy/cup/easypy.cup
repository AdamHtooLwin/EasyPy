/* ----------------------User code--------------------*/

package src;
import java.util.*;

parser code {:
    public void sem_error(String context , String message)
    {
        System.err.println("Semantic Error: "+ "<"+context+">" + message);
        System.exit(1);
    }

    public void type_error (String context, String message)
    {
        System.err.println("Type Error:"+ "<"+context+">" + message);
        System.exit(1);
    }
:};
   
/* ------------Grammar symbol declarations----------- */
   
terminal    COMMA, SEMI, EQ, PUBLISH;
terminal    PLUS, MINUS, TIMES, DIVIDE, MOD, LPAR, RPAR;
terminal    LT, GT, LTE, GTE, EQUAL, NOTEQUAL, OR, AND;
terminal    INT, BOOL, CHAR, FLOAT;

terminal Integer   INTEGER_LITERAL;
terminal Boolean   BOOLEAN_LITERAL;
terminal Float     FLOATING_LITERAL;
terminal String    CHAR_LITERAL;
terminal String    ID;

non terminal                    program, declaration, declaration_list;
non terminal Type               type;

non terminal Astat              statement, assignment, ifthen, publish, while, until_st;
non terminal Lstat              statement_list;
non terminal Aexp               E, T, F, logic;
non terminal ArrayList<String>  id_list;

/* Precedences */
precedence left SEMI;
precedence left PLUS, MINUS;
precedence left TIMES;
   
/* ------------Grammar rules----------- */

program ::= declaration_list:d SEMI statement_list:sl SEMI
                {: sl.execute(); :};

declaration_list ::= declaration_list:dl SEMI declaration:d | declaration:d;


declaration ::= type:t id_list:il
                {:
                for (String i : il){
//                    System.out.println("Declaring variable " + i + " of type " + t.getCode());
                    Memory m = Memory.getInstance();
                    if (m.SymbolTable.containsKey(i)){
                        parser.sem_error(i,"Duplicate declaration "+i);
                    }
                    m.SymbolTable.put(i, t);
                }
                :};

id_list ::=   id_list:il COMMA ID:i
            {:
                il.add(i);
                RESULT = il;
            :}
          |
            ID:i
            {:
                ArrayList<String> list = new ArrayList<String>();
                list.add(i);
                RESULT = list;
            :};

type ::= INT
            {: RESULT = new Type(Type.INTEGER, "int"); :}
        | FLOAT
            {: RESULT = new Type(Type.FLOAT, "float"); :}
        | CHAR
            {: RESULT = new Type(Type.STRING, "char"); :}
        | BOOL
            {: RESULT = new Type(Type.BOOLEAN, "bool"); :};

statement_list ::= statement_list:sl SEMI statement:s
                {: RESULT = new Lstat(sl, s); :}
              | statement:s {: RESULT = new Lstat(s); :};

statement ::= assignment:as
                {: RESULT = as; :}
                | publish:p
                {: RESULT = p; :};

assignment ::= ID:i EQ E:e
                {:
                Memory m = Memory.getInstance();
                if (!m.SymbolTable.containsKey(i)){
                    parser.sem_error(i,"Variable undeclared");
                }
                else {
                    if (m.SymbolTable.get(i).tag == e.getType().tag){
                         RESULT = Astat.assignment(i,e);
                    }
                    else {
                        parser.type_error("e", " : expression in the assignment statement must have the type " + m.SymbolTable.get(i).code);
                    }
                }
                :};

publish  ::= PUBLISH LPAR E:e RPAR
                {: RESULT = Astat.print(e); :};

E    ::= E:e PLUS T:t
                {:
                RESULT = new Aexp(new Args(e,t), sym.PLUS);
                :}
            | E:e MINUS T:t
                {:
                RESULT = new Aexp(new Args(e,t), sym.MINUS);
                :}
            | T:t
                {: RESULT = t; :};

T       ::= T:t TIMES F:f
                {:
                RESULT = new Aexp(new Args(t,f), sym.TIMES);
                :}
            | T:t DIVIDE F:f
                {:
                RESULT = new Aexp(new Args(t,f), sym.DIVIDE);
                :}
            | F:f
                {:
                RESULT = f;
                :};

F       ::= LPAR E:e RPAR
                {:
                RESULT = e;
                :}
            | INTEGER_LITERAL:n
                {:
                RESULT = new Aexp(n);
                :}
            | BOOLEAN_LITERAL:b
                {:
                RESULT = new Aexp(b);
                :}
            | FLOATING_LITERAL:f
                {:
                RESULT = new Aexp(f);
                :}
            | CHAR_LITERAL:c
                {:
                RESULT = new Aexp(c);
                :}
            | ID:i
                {:
                RESULT = new Aexp(i, true);
                :}
            ;


